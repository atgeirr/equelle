explicitHeat : Function( u_0: Collection Of Scalar On AllCells() ) -> ...
                         Collection Of Scalar On AllCells()
explicitHeat(u_0) = {
    i = StencilI()
    j = StencilJ()

	u[[i, j]] = 1/2 * u_0[[i, j+3]]
	
	q[[i, j]] = 1/4 * ( 2 * u_0[[i,j-1]] + u_0[[i,j]] + u_0[[i,j+1]] )

	#u(i, j) = 1/2 * u_0(i, j+1)
	#u£i, j€ = 1/2 * u_0£i, j+1€
	# Angrepsmåte: Implementer i handleFuncCall slik at hvis funksjonen ikke finnes, 
	# men parameterne er alle stencil-access

    #u@i,j@ = 1/8 * ( ...
   # 	  4*u_0@i,j@ ...
   # 	  + u_0@i+1,j@ ...
   # 	  + u_0@i-1,j@ ...
   # 	  + u_0@i,j+1@ ...
   # 	  + u_0@i,j-1@ ... 
   # 	) ...
    
#    	|
#    	= 1/4 ( 2 * u_0@i,j-1@ + u_0@i,j@ + u_0@i,j+1@ )
    
    # Trenger dedusere bredden på stensil for å kunne generere riktig antall ghostceller
    
    #ApplyCartesianBoundaryConditions(posX, posY, negX, negY) (periodic, reflective, ....)
    # -> Hva med negering av komponenter? (e.g., hu, hv)
    
    #støtte for fler-komponents-likninger ( [h, hu, hv]: array/tuple/vector? )
    
    # For internal boundaries (gracefull loss of order): Trenger stensilens form for å sjekke 
    # hvilke stensiler fungerer hvor
    
    #fikse navn for auto cell_stencil = [&](int i......) for å ha unike navn per stensil.

    -> u
}

