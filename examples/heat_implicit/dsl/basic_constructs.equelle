Equelle basic language constructs



# These lines are from alt. 5 and alt. 6. Some of the statements have been split and expanded for clarity,
# and some keywords are renamed in an attempt to reduce ambiguities. Comments regarding possible
# interpretations have been added.


faces : face_type(interior_faces(grid))         # Here, 'faces' is a new variable, of type 'set of face_type'.
                                                # The number of set elements is equal to the number of interior faces in the grid.
                                                # Also, each element is associated with the particular face.

faces = interior_faces(grid)                    # This sets each element of 'faces' to a face from 'interior_faces(grid)',
                                                # which could be a function returning a set or list. It could also be a "member" of 'grid'.

# Variables defined will be used freely below the point of definition, e.g., 'faces'
# will be used in place of 'interior_faces(grid)' from here on.

trans : scalar(faces)                           # Here, 'trans' is a new variable, of type 'set of scalars'.
                                                # The number of scalars is equal to the number of interior faces in the grid,
                                                # since it is equal to the number of elements in the previously defined variable (or
                                                # constant) 'faces'.
                                                # Also, each scalar is associated with the particular face.

cell_centroids : point(cells(grid))             # Similarly, this new variable is of type 'set of point', there is one point associated to
                                                # each cell in the grid.

cell_centroids2 : point(centroid(cells(grid)))  # Note that this should do the same thing, because 'cells(grid)' and
                                                # 'centroid(cells(grid))' in this context only should provide a mapping between
                                                # new elements (of which the type is the 'point') and the existing set of entities,
                                                # which in both cases is the set of cells.

cell_centroids = centroid(cells(grid))          # Only now is the variable (or constant) given actual values.


tmp : scalar(faces)                             # Declaration and assignment ( = "definition"?) combined.
    = 1.0/length(diff(cell_centroids))          # Here, 'diff' is a bit less obvious. If regarded as a function (could also be a data member
                                                # of the grid?!) it takes two cell centroids associated with a face and delivers the difference
                                                # between them. Then 'length' is the usual Euclidean length, and 1.0/... the usual scalar
                                                # division. The formulation we used in alt. 6 is probably better:

first_centr : point(faces)                      # One such for each interior face again.
    = centroid(first_cell(faces))               # The value for a given face is the centroid of the "first" cell of the given face.
                                                # The "first" and "second" cells of a face are simply the cells on each side, as an ordered pair.

second_centr : point(faces)
    = centroid(second_cell(faces))              # Now we have centroids for cells on each side of all interior faces.

reciprocal_lengths : scalar(faces)
    = 1.0/length(first_centr-second_centr)      # Elementwise subtraction, scalar division (since 1.0 is a scalar), Euclidean lengths

trans = k * area(faces) / reciprocal_lengths    # Scalar multiplication (for 'k' a scalar), elementwise division.

u : scalar(cells(grid))                         # Unknown (temperature) for each cell in the grid.

u_first : scalar(faces) = u(first_cell(faces))  # Subset of unknowns, one for each "first cell" of each face, associated with corresponding
                                                # elements of the "full" set 'u' of unknowns.
u_second : scalar(faces)
    = u(second_cell(faces))

fluxes : scalar(faces)
    = trans * ( u_first - u_second )            # Elementwise multiplication and subtraction. (Operands are sets.)

vol : scalar(cells(grid)) = volume(cells(grid)) # Only new here is the "function" 'volume' on grid cells.

residual : scalar(cells(grid))
    = u - u0 + (dt / vol) * div(fluxes)         # New here is the 'div', which, for a given cell and a set of fluxes, adds the fluxes over
                                                # all faces of that cell.
                                                # It might make sense to do this explicitly, but we haven't (yet) added code for it.
                                                # That code would correspond to the code for 'fluxes' above. The corresponding compact
                                                # "grad" version of the 'fluxes' definition, would look like this:

fluxes : scalar(faces) = - trans * grad(u)      # Note that '- grad(u)' should be equal to the 'u_first - u_second' from above.























































