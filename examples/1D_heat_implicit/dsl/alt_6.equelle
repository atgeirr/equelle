# @afr: Boundary and initial conditions are hard to generalize...
# Dirichlet boundary conditions require values on all boundaries, and the values should not be specified in the DSL.
# Also, which variable do we apply the boundary condition to?
# For now, we ignore this.




## Parts common to all alternatives

# Physics that requires specification
k = userSpecified # Heat diffusion constant. Or should this rather be an input parameter to the generated simulator?

# @afr: time step strategy assumed given outside.
dt = userSpecified # Set by outside considerations.

# u0 should be given initial values (ignored for now)
# meaning: u0 is a variable with type: one scalar per cell of the whole grid
u0 : scalar(cells(grid))
u : scalar(cells(grid))
### u : scalar on cells(grid)

# @jny: Note that similar Equelle-statements give rise to two different C++-types, V and ADB, for u0 and u.
# We should probably either make this explicit, or figure out how it can be deduced...
# Or use ADB for both of these?!




## Alternative 6

trans : scalar(faces(grid)) = k * area / length(centroid(first) - centroid(second))
### centroid(faces.first) - centroid(faces.second)

### fluxes : scalar(faces(grid)) =  trans * (u[first] - u[second])
fluxes : scalar(faces(grid)) = - trans * grad(u) # This is the one we used in 1D_heat_implicit.cpp, so let's use it also in alt_6.cpp.

vol : scalar(cells(grid)) = volume

residual : scalar(cells(grid)) = u - u0 + (dt / vol) * div(fluxes)











# Now the residual has been created. AD should also have made a Jacobian matrix.
# The following went into residual: grid, u, u0, k, dt.

# solve takes a residual, unknown. Actually, we should peek at this to know how to set up
# our AD variables
newtonsolve(residual, u)
#output(u, fluxes)
































