# Two-phase flow with no-flow boundary and simple source terms.

# Equelle note:
# Allowed primitive types:
#   Scalar, Vector (numeric types)
#   Cell, Face, Edge, Vertex (topological types)
# Allowed compound type: only sets of primitive types, associated with sets of topological entities.
# Declaration syntax for sets: <primitive type> On <set of topological type>
#
# Use type deduction by default, optional type declarations used to improve readability and detect errors.

# Physics that requires specification
perm : Scalar On Cells(Grid) = UserSpecifiedScalars()
poro : Scalar On Cells(Grid) = UserSpecifiedScalars()

# @afr: time step strategy assumed given outside.
dt : Scalar = UserSpecifiedScalarWithDefault(Days(1.0)) # Time step length.

# s0 should be given initial values (in user input)
s0 : Scalar On Cells(Grid) = UserSpecifiedScalars()

s : Scalar On Cells(Grid) = s0
p : Scalar On Cells(Grid) = 0

# Constants
vol = Volume(Cells(Grid))                                  # Deduced type: Scalar On Cells(Grid)

# EntitySet : Collection Of <Entity> On <XXX>
# Collection Of <Type> On <Entityset> == Collection Of <Type> On <XXX>

# computeTransmissibilities : Function() -> Collection Of Scalar On InternalFaces(Grid)
computeTransmissibilities() = {
    # InternalFaces : Function() -> Collection Of Face
    # internal_faces : Collection Of Face
    internal_faces = InternalFaces(Grid)
    # FirstCell : Function(facecoll : Collection Of Face) -> Collection Of Cell On facecoll
    # first : Collection Of Cell On internal_faces
    first = FirstCell(internal_faces)
    # SecondCell : Function(facecoll : Collection Of Face) -> Collection Of Cell On facecoll
    # second : Collection Of Cell On internal_faces
    second = SecondCell(internal_faces)
    # Centroid : Function(cellcoll : Collection Of Cell) -> Collection of Vector On cellcoll
    # Centroid : Function(facecoll : Collection Of Face) -> Collection of Vector On facecoll
    # Centroid(first) : Collection of Vector On first
    # Centroid(internal_faces) : Collection of Vector On internal_faces
    # cdiff1 : Collection of Vector On internal_faces (since first is 'On' internal_faces)
    cdiff1 = Centroid(first) - Centroid(internal_faces)        # Deduced type: Vector On internal_faces
    cdiff2 = Centroid(second) - Centroid(internal_faces)       # Deduced type: Vector On internal_faces
    p1 = perm(first)                                           # Deduced type: Scalar On internal_faces
    p2 = perm(second)                                          # Deduced type: Scalar On internal_faces
    a = Area(internal_faces)                                   # Deduced type: Scalar On internal_faces
    halftrans1 = a * p1 * Dot(Normal(internal_faces), cdiff1) / Length(cdiff1)^2
    halftrans2 = a * p2 * Dot(Normal(internal_faces), cdiff2) / Length(cdiff2)^2
    trans = 1.0 / (1.0/halftrans1 + 1.0/halftrans2)
    return trans
}

upstream : Function(flux : Scalar On InternalFaces(Grid),
                    x    : Scalar On Cells(Grid))
           -> Scalar On InternalFaces(Grid)
upstream(flux, x) = {
    x1 = x(FirstCell(InternalFaces(Grid)));
    x2 = x(SecondCell(InternalFaces(Grid)));
    return flux > 0 ? x1 : x2
}

# Deduced (and declared) type: Scalar On internal_faces
trans : Scalar On internal_faces = computeTransmissibilities()

# Variable quantities
# Deduced (and declared) type: Scalar On internal_faces
fluxes : Scalar On internal_faces = - trans * Gradient(p)
# Deduced (and declared) type: Scalar On Cells(Grid)
residual : Scalar On Cells(Grid) = u - u0 + (dt / vol) * Divergence(fluxes)


# solve takes a residual and the primary variable. The primary variable decides which objects need to be AD objects in
# the back-end, the rule is the following:
#  1. The primary variable must be AD.
#  2. All objects that depend on an AD variable must be AD.
# In this concrete case, { u, fluxes, residual } must be AD.
NewtonSolve(residual, u)

Output(u)
Output(fluxes)
































