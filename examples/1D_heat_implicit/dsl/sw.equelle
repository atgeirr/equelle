#! -*-sh-*-
# Shallow water...

cfl : Scalar = UserSpecifiedScalarWithDefault(0.9) # Courant number <= 1
g : Scalar = UserSpecifiedScalarWithDefault(9.81) # Gravitational constant

# initial values (in user input)
h0 : Collection Of Scalar On AllCells() = UserSpecifiedCollectionOfScalar( AllCells() ) # Water elevation
hu0 : Collection Of Scalar On AllCells() = UserSpecifiedCollectionOfScalar( AllCells() ) # Momentum along x-axis
hv0 : Collection Of Scalar On AllCells() = UserSpecifiedCollectionOfScalar( AllCells() ) # Momentum along y-axis

# Create a tuple of our physical variables to enable "vector notation" that is close to the mathematics
q0 : Tuple of (Collection Of Scalar On AllCells()) = (h0, hu0, hv0) #What kind of parenthesis do we need here?

# Copy initial conditions
q = q0

# Part of the shallow water equations: fluxes along x-axis and y-axis
f(q) = {
	h = q[0]
	hu = q[1]
	hv = q[2]
	
	return (hu, ...
		hu*hu/h + (1/2)*g*h*h, ...
		hu*hv/h)
}
g(q) = {
	h = q[0]
	hu = q[1]
	hv = q[2]
	
	return (hu, ...
		hu*hv/h, ...
		hv*hv/h + (1/2)*g*h*h)
}


# The central upwind flux function for an integration point with a normal direction
# We use classical Riemann problem notation with a right and left state
# The function takes the state on the left hand side, right hand side, and the normal as input
compute_flux(ql, qr, n) = {	
	# Create aliases for h and hu for the left and right hand side of the integration point
	hl = ql[0]
	hul = ql[1]
	hvl = ql[2]
	hr = qr[0]
	hur = qr[1]
	hvr = qr[2]

	# p is the wave speed for the integration point in the normal direction (be ware of small h for certain calculations: not handled yet)
	# We need to get the 
	pl = Dot((hul, hvl) / hl, n)
	pr = Dot((hur, hvr) / hr, n)

	# c is the gravitational potential leading to potentially increased wave speeds
	cl = Sqrt(g*hl)
	cr = Sqrt(g*hr)

	# am and ap are the min / max eigenvalues (wave speeds) for a face (or integration point...)
	am = Min(Min(pl-cl, pr-cr), 0)
	ap = Max(Max(pl+cl, pr+cr), 0)
	
	# Use the central upwind flux function to calculate the x- and y-components of the flux
	f_flux = (ap * f(ql) - am * f(qr)) / (ap-am)
	g_flux = (ap * f(ql) - am * f(qr)) / (ap-am)
	
	# Find the flux in the normal direction
	flux = Dot((f_flux, g_flux), n)

	#Stabilization term in the central upwind function
	central_upwind_correction = ap*am*(ql - qr) / (ap-am)
	
	# Find the flux for the given integration point
	return flux - central_upwind_correction
}



# Reconstructs a plane for each cell in the grid, with a slope limiter
reconstruct_plane(q) = {
	# forward_diff_x = (q_right - q) / dx
	# backward_diff_x = (q - q_left) / dx
	# centered_diff_x = (q_right - q_left) / (2*dx)
	
	# forward_diff_y = (q_up - q) / dy
	# backward_diff_y = (q - q_down) / dy
	# centered_diff_y = (q_up - q_down) / (2*dy)

	# x_slope = minmod (forward_diff_x, backward_diff_x, centered_diff_x)
	# y_slope = minmod (forward_diff_y, backward_diff_y, centered_diff_y)
	
	# return (x_slope, y_slope)
}

# Get all cells and faces, which will be used later
if = InteriorFaces()
first = FirstCell(if)
second = SecondCell(if)

# Reconstruct a higher-order approximation to the physical quantities within each cell.
# In this case, we reconstruct a plane, but for higher order, we typically reconstruct
# a higher-order polynomial
slopes = reconstruct_plane(AllCells())

#Find the normal and tangent for the interface
n = Normal(if)
t = (n[1] / n[0], -1)
t = t / EuclideanLength(t)

# Find the length from the cell center to the integration point
first_to_ip = EuclideanLength(Centroid(first), Centroid(if)) # +- t*Length(if)/(2*Sqrt(3)) for a two point gauss quadrature
second_to_ip = EuclideanLength(Centroid(second), Centroid(if))

# Evaluate the reconstructed variables at the integration point
q1 = q On first + first_to_ip*Dot(slopes On first, n)
q2 = q On second + second_to_ip*Dot(slopes On first, n)

# Compute the flux at the integration point
fluxes = compute_flux(q1, q2, n)

# Constants
#vol = Volume( AllCells() )                                 # Deduced type:  Collection Of Scalar On AllCells()				   
#trans : Collection Of Scalar On interior_faces = k * Area(interior_faces) / EuclideanLength(Centroid(first) - Centroid(second)) 
							   
# compute_residual : Function(u : Collection Of Scalar On AllCells()) -> Collection Of Scalar On AllCells()
compute_residual(u) = {
    # Deduced (and declared) type: Collection Of Scalar On interior_faces
    fluxes : Collection Of Scalar On interior_faces = - trans * Gradient(u)
    # Deduced (and declared) type: Collection Of Scalar On AllCells()
    residual : Collection Of Scalar On AllCells() = u - u0 + (dt / vol) * Divergence(fluxes)
    return residual
}

# NewtonSolve takes a function (that should accept the primary variable as input) and the initial guess for the primary variable.
# The primary variable decides which objects need to be AD objects in
# the back-end, the rule is the following:
#  1. The primary variable must be AD.
#  2. All objects that depend on an AD variable must be AD.
# In this concrete case, { u, fluxes, residual } must be AD.
explicitu = u0 + compute_residual(u0)
u = NewtonSolve(compute_residual, u0)

Output(u)
Output(fluxes)
































