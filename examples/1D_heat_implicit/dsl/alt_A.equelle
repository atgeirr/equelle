#! -*-sh-*-
# Heat conduction with no boundary conditions or source terms.

# Physics that requires specification
k : Scalar = UserSpecifiedScalarWithDefault(0.3) # Heat diffusion constant.

# @afr: time step strategy assumed given outside.
dt : Scalar = UserSpecifiedScalarWithDefault(0.5) # Time step length.

# u0 should be given initial values (in user input)
u0 : Collection Of Scalar On AllCells() = UserSpecifiedCollectionOfScalar( AllCells() )

# Trying to add support for Dirichlet boundaries
dirichlet_boundary : Collection Of Face On BoundaryFaces() = UserSpecifiedCollectionOfFace( BoundaryFaces() )
dirichlet_val : Collection Of Scalar On dirichlet_boundary = UserSpecifiedCollectionOfScalar( dirichlet_boundary )

# Constants
vol = |AllCells()|                                         # Deduced type:  Collection Of Scalar On AllCells()
interior_faces = InteriorFaces()                           # Deduced type:  Collection Of Face
first = FirstCell(interior_faces)                          # Deduced type:  Collection Of Cell On interior_faces
							   # Equivalent to: Collection Of Cell On InteriorFaces()
second = SecondCell(interior_faces)                        # Deduced type:  Same as for 'first'.
itrans : Collection Of Scalar On interior_faces = k * |interior_faces| / |Centroid(first) - Centroid(second)| 

# Computing boundary transmissibilities.
# New Equelle function: IsEmpty() and new concept, empty or null entities.
bf = BoundaryFaces()
bf_cells = IsEmpty(FirstCell(bf)) ? SecondCell(bf) : FirstCell(bf)
bf_sign = IsEmpty(FirstCell(bf))) ? (-1 On bf_cells) : (1 On bf_cells)
btrans = k * |bf| / |Centroid(bf) - Centroid(bf_cells)|


# compute_residual : Function(u : Collection Of Scalar On AllCells()) -> Collection Of Scalar On AllCells()
compute_residual(u) = {
    # Deduced (and declared) type: Collection Of Scalar On interior_faces
    ifluxes : Collection Of Scalar On interior_faces = - itrans * Gradient(u)
    # Adding Dirichlet boundary support
    # The next line assumes a new function: SingleCell)=
    bfluxes : Collection Of Scalar On dirichlet_boundary
    bfluxes = (bf_sign On dirichlet_boundary) * (u On (bf_cells On dirichlet_boundary) - dirichlet_val)
    fluxes = (ifluxes On AllFaces()) + (bfluxes On AllFaces())
    # Deduced (and declared) type: Collection Of Scalar On AllCells()
    residual : Collection Of Scalar On AllCells() = u - u0 + (dt / vol) * Divergence(fluxes)
    return residual
}

# NewtonSolve takes a function (that should accept the primary variable as input) and the initial guess for the primary variable.
# The primary variable decides which objects need to be AD objects in
# the back-end, the rule is the following:
#  1. The primary variable must be AD.
#  2. All objects that depend on an AD variable must be AD.
# In this concrete case, { u, fluxes, residual } must be AD.
explicitu = u0 + compute_residual(u0)
u = NewtonSolve(compute_residual, u0)

Output(u)
Output(fluxes)
































