# Two-phase flow with no-flow boundary and simple source terms.

# Equelle note:
# Allowed primitive types:
#   Scalar, Vector (numeric types)
#   Cell, Face, Edge, Vertex (topological types)
# Allowed compound type: only sets of primitive types, associated with sets of topological entities.
# Declaration syntax for sets: <primitive type> On <set of topological type>
#
# Use type deduction by default, optional type declarations used to improve readability and detect errors.

# Physics that requires specification
perm : Collection Of Scalar On AllCells()
perm = UserSpecifiedCollectionOfScalar("perm", AllCells())
poro : Collection Of Scalar On AllCells()
poro = UserSpecifiedCollectionOfScalar("poro", AllCells())

# s0 should be given initial values (in user input)
s0 : Collection Of Scalar On AllCells()
s0 = UserSpecifiedCollectionOfScalar("s0", AllCells())

s : Collection Of Scalar On AllCells()
s = s0
p : Collection Of Scalar On AllCells()
p = 0.0 On AllCells()

# Constants
vol = |AllCells()|


computeTransmissibilities : Function(permeability : Collection Of Scalar On AllCells()) -> Collection Of Scalar On InteriorFaces()
computeTransmissibilities(permeability) = {
    # InteriorFaces : Function() -> Collection Of Face
    # interior_faces : Collection Of Face
    interior_faces = InteriorFaces()
    # FirstCell : Function(facecoll : Collection Of Face) -> Collection Of Cell On facecoll
    # first : Collection Of Cell On interior_faces
    first = FirstCell(interior_faces)
    # SecondCell : Function(facecoll : Collection Of Face) -> Collection Of Cell On facecoll
    # second : Collection Of Cell On interior_faces
    second = SecondCell(interior_faces)
    # Centroid : Function(cellcoll : Collection Of Cell) -> Collection of Vector On cellcoll
    # Centroid : Function(facecoll : Collection Of Face) -> Collection of Vector On facecoll
    # Centroid(first) : Collection of Vector On first
    # Centroid(interior_faces) : Collection of Vector On interior_faces
    # cdiff1 : Collection of Vector On interior_faces (since first is 'On' interior_faces)
    cdiff1 = Centroid(first) - Centroid(interior_faces)        # Deduced type: Vector On interior_faces
    cdiff2 = Centroid(second) - Centroid(interior_faces)       # Deduced type: Vector On interior_faces
    p1 = permeability On first                                 # Deduced type: Scalar On interior_faces
    p2 = permeability On second                                # Deduced type: Scalar On interior_faces
    a = |interior_faces|                                       # Deduced type: Scalar On interior_faces
    halftrans1 = a * p1 * Dot(Normal(interior_faces), cdiff1) / Dot(cdiff1, cdiff1)
    halftrans2 = a * p2 * Dot(Normal(interior_faces), cdiff2) / Dot(cdiff2, cdiff2)
    trans = 1.0 / (1.0/halftrans1 + 1.0/halftrans2)
    -> trans
}

upstream : Function(flux : Collection Of Scalar On InteriorFaces(), ...
                    x    : Collection Of Scalar On AllCells()) ...
                    -> Collection Of Scalar On InteriorFaces()
upstream(flux, x) = {
    x1 = x On FirstCell(InteriorFaces())
    x2 = x On SecondCell(InteriorFaces())
    -> flux# > 0 ? x1 : x2
}

# Deduced (and declared) type: Scalar On interior_faces
trans : Collection Of Scalar On InteriorFaces()
trans = computeTransmissibilities(perm)

# Variable quantities
# Deduced (and declared) type: Scalar On interior_faces
computeFluxes : Function(p : Collection Of Scalar On AllCells()) ...
                         -> Collection Of Scalar On InteriorFaces()
computeFluxes(p) = {
    -> - trans * Gradient(p)
}

# Deduced (and declared) type: Scalar On Cells(Grid)
computeResidual : Function(u  : Collection Of Scalar On AllCells(), ...
                           u0 : Collection Of Scalar On AllCells(), ...
                           dt : Scalar) ...
                           -> Collection Of Scalar On AllCells()
computeResidual(u, u0, dt) = 
{
    fluxes = computeFluxes(u)
    -> u - u0 + (dt / vol) * Divergence(fluxes)
}


timesteps = UserSpecifiedSequenceOfScalar("timesteps")
u_initial = UserSpecifiedCollectionOfScalar("u_initial", AllCells())
u0 : Mutable Collection Of Scalar On AllCells()
u0 = u_initial

For dt In timesteps {
    computeResidualLocal : Function(u : Collection Of Scalar On AllCells()) -> Collection Of Scalar On AllCells()
    computeResidualLocal(u) = {
        -> computeResidual(u, u0, dt)
    }
    u_guess = u0
    u = NewtonSolve(computeResidualLocal, u_guess)
    Output("u", u)
    u0 = u
}































