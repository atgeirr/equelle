# @afr: Boundary and initial conditions are hard to generalize...
# Dirichlet boundary conditions require values on all boundaries, and the values should not be specified in the DSL.
# Also, which variable do we apply the boundary condition to?
# For now, we ignore this.



## Parts common to all alternatives

# Physics that requires specification
k = userSpecified # Heat diffusion constant. Or should this rather be an input parameter to the generated simulator?

# @afr: time step strategy assumed given outside.
dt = userSpecified # Set by outside considerations.


# u0 should be given initial values (ignored for now)
# meaning: u0 is a variable with type: one scalar per cell of the whole grid
u0 : scalar(cells(grid))
u : scalar(cells(grid))
### u : scalar on cells(grid)



## Alternative 1

centroid_distances : scalar(faces(grid))
# meaning: centroid_distances is a variable with type: one scalar per face of the whole grid
for f in faces(grid):
    # faces(grid) means: all faces in the grid
    centroid_distances[f] = length(centroid(first(f)) - centroid(second(f)))
    ### length(f.first.centroid - f.second.centroid)

residual: scalar(cells(grid))
for c in cells(grid):
    # cells(grid) means: all cells in the grid
    residual[c] = u[c] - u0[c]
    for f in faces(c): # Note that as written, this loop cannot be parallel, due to accumulation in residual[c].
        # faces(c) means: all faces adjacent to c
        neighbour_cell = cell(f, c) # Meaning: the neighbour cell of f that is not c.
        ### neighbour_cell = f.cellMate(c)
        residual[c] += (dt / volume(c)) * k * area(f) * (u[neighbour_cell] - u[c]) / centroid_distances[f]



## Alternative 2

fluxes : scalar(faces(grid))
for f in faces(grid):
    centroid_distance = length(centroid(first(f)) - centroid(second(f)))
    fluxes[f] = k * area(f) * (u[first(f)] - u[second(f)]) / centroid_distance

residual: scalar(cells(grid))
for c in cells(grid):
    residual[c] = u[c] - u0[c]
    for (f in faces(c)): # Note that as written, this loop cannot be parallel, due to accumulation in residual[c].
        residual[c] += (dt / volume(c)) * fluxes[f] * orientationsign(c, f)
        ### orientationsign -> osign || f.neighboursign(c) || f.dir(c) || dir(c, f)



## Alternative 3

fluxes : scalar(faces(grid))
for f in faces(grid):
    centroid_distance = length(centroid(first(f)) - centroid(second(f)))
    fluxes[f] = k * area(f) * (u[first(f)] - u[second(f)]) / centroid_distance

residual: scalar(cells(grid))
for c in cells(grid):
    residual[c] = u[c] - u0[c] + (dt / volume(c)) * div(fluxes, c)
    ### div -> c.div(fluxes) || c.fsum(fluxes) || c.divergence(fluxes) || c.nabla(fluxes)



## Alternative 4

fluxes : scalar(faces(grid))
for f in faces(grid):
    centroid_distance = length(centroid(first(f)) - centroid(second(f)))
    fluxes[f] = k * area(f) * (u[first(f)] - u[second(f)]) / centroid_distance

vol : scalar(cells(grid))
for c in cells(grid):
    vol[c] = volume(c)

residual: scalar(cells(grid))
residual = u - u0 + (dt / vol) * div(fluxes)



## Alternative 5

trans : scalar(faces(grid)) = k * area(faces(grid)) / length(diff(centroid(cells(grid))))

fluxes : scalar(faces(grid)) = - trans * grad(u)

vol : scalar(cells(grid)) = volume(cells(grid))

residual : scalar(cells(grid)) = u - u0 + (dt / vol) * div(fluxes)




## Alternative 6

trans : scalar(faces(grid)) = k * area / length(centroid(first) - centroid(second))
### centroid(faces.first) - centroid(faces.second)

fluxes : scalar(faces(grid)) =  trans * (u[first] - u[second])
### - trans * grad(u)

vol : scalar(cells(grid)) = volume

residual : scalar(cells(grid)) = u - u0 + (dt / vol) * div(fluxes)

# Now the residual has been created. AD should also have made a Jacobian matrix.
# The following went into residual: grid, u, u0, k, dt.

# solve takes a residual, unknown. Actually, we should peek at this to know how to set up
# our AD variables
newtonsolve(residual, u)
#output(u, fluxes)

# @afr: This should be automatic I think.
# simulator.generate("generated_1D_heat_implicit.cpp")
